/*
https://leetcode.com/problems/missing-number/
Given an array containing n distinct numbers taken from 0, 1, 2, ..., n, find the one that is missing from the array.
Example 1:
Input: [3,0,1]
Output: 2

Example 2:
Input: [9,6,4,2,3,5,7,0,1]
Output: 8
Note: Your algorithm should run in linear runtime complexity. Could you implement it using only constant extra space complexity?
*/

class Solution {
    public int missingNumber(int[] nums) {
        int num = nums.length;
        // Only the missing element will be left after the XOR.
        for (int i = 0; i < nums.length; i++) {
            num = num ^ i ^ nums[i];
        }
        return num;
    }
}

/*
https://www.geeksforgeeks.org/find-two-non-repeating-elements-in-an-array-of-repeating-elements/
Find the two non-repeating elements in an array of repeating elements.
*/

public class FindTwoNonRepeatingElementsInArray {
	public static void main(String[] args) {
		int[] nums = {2, 3, 7, 9, 11, 2, 3, 11}; 
		findNonRepeatingElem(nums);
	}	
	public static void findNonRepeatingElem(int[] nums) {
		int xor = 0;		
		for (int num : nums) xor = xor ^ num; // xor = 7 ^ 9.
		// Note that 7 & (7 - 1) will change the right most set bit to 0 and rest as it is.
		// While, 7 & ~(7 - 1) will leave only the right most set bit as it is and rest other bits will become 0.
		// Also, just a trick the above can also be written as: 7 & -7. As -7 = ~(7 - 1)
		int rightMostSetNum = xor & ~(xor - 1);
		int a = 0, b = 0;
		for (int num : nums) {
			// all the nums which don't have the bit set will be 0 and go the a bucket.
			// and the duplicates one will automatically nullify by the second occurence of the duplicate.
			if ((rightMostSetNum & num) == 0) a = a ^ num;
			else b = b ^ num;
		}
		System.out.println("Non repeating numbers are: " + a + ", " + b); // outputs 7 and 9. 
	}
}

/*
A combination of above 2 concepts.
A combination of the above 2 problems: https://www.geeksforgeeks.org/find-a-repeating-and-a-missing-number/
Given an unsorted array of size n. Array elements are in the range from 1 to n. One number from set {1, 2, â€¦n} 
is missing and one number occurs twice in the array. Find these two numbers.

Input: arr[] = {3, 1, 3}
Output: Missing = 2, Repeating = 3
Explanation: In the array, 
2 is missing and 3 occurs twice 

Input: arr[] = {4, 3, 6, 2, 1, 1}
Output: Missing = 5, Repeating = 1
*/

public class RepeatingAndMissing {
	public static void main(String[] args) 
    { 
        int arr[] = { 7, 3, 4, 5, 5, 6, 2 }; 
        int n = arr.length; 
        printTwoElements(arr); 
    }
	
	public static void printTwoElements(int[] nums) {
		int xor = 0;
		int n = nums.length;
		// XOR all elements.
		for (int num : nums) xor ^= num;
		for (int i = 1; i <= n; i++) xor ^= i;
		int a = 0, b = 0;
		int lastSetBit = xor & ~(xor - 1);
		// Getting the 2 elements back from XOR.
		for (int num : nums) {
			if ((lastSetBit & num) == 0) a ^= num;
			else b ^= num;
		}
		for (int i = 1; i <= n; i++) {
			if ((lastSetBit & i) == 0) a ^= i;
			else b ^= i;
		}
		
		// To get which one's missing and which one's repeating.
		int repeating = b, missing = a;
		for (int num : nums) {
			if (num == a) {
				repeating = a;
				missing = b;
				break;
			}
		}		
		System.out.println("repeating: " + repeating + ", missing: " + missing); // repeating: 5, missing: 1
	}
}
